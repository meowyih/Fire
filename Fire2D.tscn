[gd_scene load_steps=18 format=2]

[ext_resource path="res://Fire2D.gd" type="Script" id=1]

[sub_resource type="Shader" id=1]
code = "shader_type canvas_item;

uniform float strength : hint_range( 1.0, 20.0 ) = 3.;
uniform float speed : hint_range( 0.0, 20.0 ) = 0.;

// procedural noise from IQ
vec2 hash( vec2 p )
{
	p = vec2( dot(p,vec2(127.1,311.7)),
			 dot(p,vec2(269.5,183.3)) );
	return -1.0 + 2.0*fract(sin(p)*43758.5453123);
}

float noise( in vec2 p )
{
	const float K1 = 0.366025404; // (sqrt(3)-1)/2;
	const float K2 = 0.211324865; // (3-sqrt(3))/6;
	
	vec2 i = floor( p + (p.x+p.y)*K1 );
	
	vec2 a = p - i + (i.x+i.y)*K2;
	vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0);
	vec2 b = a - o + K2;
	vec2 c = a - 1.0 + 2.0*K2;
	
	vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );
	
	vec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));
	
	return dot( n, vec3(70.0) );
}

float fbm(vec2 uv)
{
	float f;
	mat2 m = mat2( vec2(1.6,  1.2), vec2(-1.2,  1.6) );
	f  = 0.5000*noise( uv ); uv = m*uv;
	f += 0.2500*noise( uv ); uv = m*uv;
	f += 0.1250*noise( uv ); uv = m*uv;
	f += 0.0625*noise( uv ); uv = m*uv;
	f = 0.5 + 0.5*f;
	return f;
}

//
// moving fbm
//
void fragment()
{
	// a simple moving pattern fbm 
	float n = fbm(strength*UV + vec2(0,speed * TIME));
	COLOR = vec4( vec3(n), 1. );
}"

[sub_resource type="ShaderMaterial" id=2]
shader = SubResource( 1 )
shader_param/strength = 3.0
shader_param/speed = 0.0

[sub_resource type="Shader" id=3]
code = "shader_type canvas_item;

uniform float strength : hint_range( 1.0, 20.0 ) = 3.;
uniform float speed : hint_range( 0.0, 20.0 ) = 0.;

uniform int crgb : hint_range(0,2) = 0;

// procedural noise from IQ
vec2 hash( vec2 p )
{
	p = vec2( dot(p,vec2(127.1,311.7)),
			 dot(p,vec2(269.5,183.3)) );
	return -1.0 + 2.0*fract(sin(p)*43758.5453123);
}

float noise( in vec2 p )
{
	const float K1 = 0.366025404; // (sqrt(3)-1)/2;
	const float K2 = 0.211324865; // (3-sqrt(3))/6;
	
	vec2 i = floor( p + (p.x+p.y)*K1 );
	
	vec2 a = p - i + (i.x+i.y)*K2;
	vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0);
	vec2 b = a - o + K2;
	vec2 c = a - 1.0 + 2.0*K2;
	
	vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );
	
	vec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));
	
	return dot( n, vec3(70.0) );
}

float fbm(vec2 uv)
{
	float f;
	mat2 m = mat2( vec2(1.6,  1.2), vec2(-1.2,  1.6) );
	f  = 0.5000*noise( uv ); uv = m*uv;
	f += 0.2500*noise( uv ); uv = m*uv;
	f += 0.1250*noise( uv ); uv = m*uv;
	f += 0.0625*noise( uv ); uv = m*uv;
	f = 0.5 + 0.5*f;
	return f;
}

int eq( int a, int b )
{
	return 1 - abs(sign(a - b));
}

//
// color
//
void fragment()
{
	float n = fbm(strength*UV + vec2(0,speed*TIME));
	vec3 col = vec3(1.5*n, 1.5*n*n*n, n*n*n*n*n*n);
	
	// col is red, col.zyx is blue, .85*col.yxz is green
	col = col * vec3(float(eq( crgb, 0 ))) + col.zyx * vec3(float(eq( crgb, 1 ))) +  0.85 *  col.yxz * vec3(float(eq( crgb, 2 )));
	COLOR = vec4( vec3(col), 1. );
}"

[sub_resource type="ShaderMaterial" id=4]
shader = SubResource( 3 )
shader_param/strength = 3.0
shader_param/speed = 0.0
shader_param/crgb = 0

[sub_resource type="Shader" id=7]
code = "shader_type canvas_item;

uniform float strength : hint_range( 1.0, 20.0 ) = 3.;
uniform float speed : hint_range( 0.0, 20.0 ) = 0.;

uniform int crgb : hint_range(0,2) = 0;

uniform float power : hint_range(1., 20.) = 5.0;
uniform float x_width : hint_range(0.1, 20.) = 4.0;
uniform float y_height : hint_range(0.1, 20.) = 0.4;

// procedural noise from IQ
vec2 hash( vec2 p )
{
	p = vec2( dot(p,vec2(127.1,311.7)),
			 dot(p,vec2(269.5,183.3)) );
	return -1.0 + 2.0*fract(sin(p)*43758.5453123);
}

float noise( in vec2 p )
{
	const float K1 = 0.366025404; // (sqrt(3)-1)/2;
	const float K2 = 0.211324865; // (3-sqrt(3))/6;
	
	vec2 i = floor( p + (p.x+p.y)*K1 );
	
	vec2 a = p - i + (i.x+i.y)*K2;
	vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0);
	vec2 b = a - o + K2;
	vec2 c = a - 1.0 + 2.0*K2;
	
	vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );
	
	vec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));
	
	return dot( n, vec3(70.0) );
}

float fbm(vec2 uv)
{
	float f;
	mat2 m = mat2( vec2(1.6,  1.2), vec2(-1.2,  1.6) );
	f  = 0.5000*noise( uv ); uv = m*uv;
	f += 0.2500*noise( uv ); uv = m*uv;
	f += 0.1250*noise( uv ); uv = m*uv;
	f += 0.0625*noise( uv ); uv = m*uv;
	f = 0.5 + 0.5*f;
	return f;
}

int eq( int a, int b )
{
	return 1 - abs(sign(a - b));
}

void fragment()
{
	vec2 uv = UV - vec2( 0.5, 0 ); // change uv.x to [-0.5 ~ 0.5]
	float n = fbm(strength*UV + vec2(0.,speed*TIME));
	vec3 color = vec3(1.5*n, 1.5*n*n*n, n*n*n*n*n*n);
	
	// float modifier = 1. - uv.y; // the lower, the darker
	// float modifier = pow(1. - uv.y, 0.4); // the more 'pow', the more darker range
	
	// float modifier = 1. - abs(uv.x); // closer to the center, the brighter
	// float modifier = pow(1. - abs(uv.x), 4.); // the more 'pow', the center is brigther
	
	float modifier = power * ( pow(1. - uv.y, y_height) + n * max(0., 0.7 - uv.y )) + n * max( abs(uv.y - 0.3), 0.) * pow(1. - abs(uv.x), x_width);
	color = color * modifier;
	
	// col is red, col.zyx is blue, .85*col.yxz is green
	color = color * vec3(float(eq( crgb, 0 ))) + color.zyx * vec3(float(eq( crgb, 1 ))) +  0.85 *  color.yxz * vec3(float(eq( crgb, 2 )));
	
	COLOR = vec4( vec3(color), 1. );
}"

[sub_resource type="ShaderMaterial" id=8]
shader = SubResource( 7 )
shader_param/strength = 3.0
shader_param/speed = 0.0
shader_param/crgb = 0
shader_param/power = 1.0
shader_param/x_width = 4.0
shader_param/y_height = 1.5

[sub_resource type="Shader" id=9]
code = "shader_type canvas_item;

uniform float strength : hint_range( 1.0, 20.0 ) = 3.;
uniform float speed : hint_range( 0.0, 20.0 ) = 0.;

uniform float contrast : hint_range( 0.0, 10.0 ) = 3.0;
uniform float dnoise : hint_range( 0.0, 1.0 ) = 0.25;
uniform float whiteness : hint_range( 0.0, 20.0 ) = 10.;

// procedural noise from IQ
vec2 hash( vec2 p )
{
	p = vec2( dot(p,vec2(127.1,311.7)),
			 dot(p,vec2(269.5,183.3)) );
	return -1.0 + 2.0*fract(sin(p)*43758.5453123);
}

float noise( in vec2 p )
{
	const float K1 = 0.366025404; // (sqrt(3)-1)/2;
	const float K2 = 0.211324865; // (3-sqrt(3))/6;
	
	vec2 i = floor( p + (p.x+p.y)*K1 );
	
	vec2 a = p - i + (i.x+i.y)*K2;
	vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0);
	vec2 b = a - o + K2;
	vec2 c = a - 1.0 + 2.0*K2;
	
	vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );
	
	vec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));
	
	return dot( n, vec3(70.0) );
}

float fbm(vec2 uv)
{
	float f;
	mat2 m = mat2( vec2(1.6,  1.2), vec2(-1.2,  1.6) );
	f  = 0.5000*noise( uv ); uv = m*uv;
	f += 0.2500*noise( uv ); uv = m*uv;
	f += 0.1250*noise( uv ); uv = m*uv;
	f += 0.0625*noise( uv ); uv = m*uv;
	f = 0.5 + 0.5*f;
	return f;
}

void fragment()
{
	// a simple moving pattern fbm
	vec2 uv = UV - vec2( 0.5, 0 ); // uv.x [-0.5 ~ 0.5]
	float n = fbm(strength*UV + vec2(0,speed * TIME));
	// 'pow( n, contrast)' is to increase the contrast
	// '- dnoise' is to remove the white color that lower than dnoise (0.25)
	// 'whiteness *' is to make it black and white only 
	COLOR = vec4( vec3( whiteness * max(0., pow(n, contrast) - dnoise)), 1. );
}"

[sub_resource type="ShaderMaterial" id=10]
shader = SubResource( 9 )
shader_param/strength = 3.0
shader_param/speed = 0.0
shader_param/contrast = 1.0
shader_param/dnoise = 0.25
shader_param/whiteness = 3.0

[sub_resource type="Shader" id=11]
code = "shader_type canvas_item;

uniform float strength : hint_range( 1.0, 20.0 ) = 3.;
uniform float speed : hint_range( 0.0, 20.0 ) = 0.;

uniform float contrast : hint_range( 0.0, 10.0 ) = 4.;
uniform float dnoise : hint_range( 0.0, 1.0 ) = 0.25;
uniform float whiteness : hint_range( 0.0, 20.0 ) = 10.;

uniform float height : hint_range( 0.0, 2.0 ) = 1.0;

// procedural noise from IQ
vec2 hash( vec2 p )
{
	p = vec2( dot(p,vec2(127.1,311.7)),
			 dot(p,vec2(269.5,183.3)) );
	return -1.0 + 2.0*fract(sin(p)*43758.5453123);
}

float noise( in vec2 p )
{
	const float K1 = 0.366025404; // (sqrt(3)-1)/2;
	const float K2 = 0.211324865; // (3-sqrt(3))/6;
	
	vec2 i = floor( p + (p.x+p.y)*K1 );
	
	vec2 a = p - i + (i.x+i.y)*K2;
	vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0);
	vec2 b = a - o + K2;
	vec2 c = a - 1.0 + 2.0*K2;
	
	vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );
	
	vec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));
	
	return dot( n, vec3(70.0) );
}

float fbm(vec2 uv)
{
	float f;
	mat2 m = mat2( vec2(1.6,  1.2), vec2(-1.2,  1.6) );
	f  = 0.5000*noise( uv ); uv = m*uv;
	f += 0.2500*noise( uv ); uv = m*uv;
	f += 0.1250*noise( uv ); uv = m*uv;
	f += 0.0625*noise( uv ); uv = m*uv;
	f = 0.5 + 0.5*f;
	return f;
}

void fragment()
{
	vec2 uv = UV - vec2( 0.5, 0 ); // uv.x [-0.5 ~ 0.5]
	float n = fbm(strength*UV + vec2(0,speed * TIME));
	
	// the contrast changed based on the y axis
	// if I use ( 1. - uv.y ), 1/3 of the uv are white, it seems
	// the good uv.y is between [0 ~ 0.7] only
	// so I change ( 1. - uv.y ) to max(0., ( 1.3 - uv.y ))
	// then use uniform to change to max( 0., (height  - uv.y)) 
	COLOR = vec4( vec3( whiteness * max(0., pow(n, contrast * max( 0., height - uv.y)) - dnoise)), 1. );
}"

[sub_resource type="ShaderMaterial" id=12]
shader = SubResource( 11 )
shader_param/strength = 3.0
shader_param/speed = 0.0
shader_param/contrast = 4.588
shader_param/dnoise = 0.25
shader_param/whiteness = 10.0
shader_param/height = 1.343

[sub_resource type="Shader" id=13]
code = "shader_type canvas_item;

uniform float c_v : hint_range( 0., 1. ) = 0.25;
uniform float c_h : hint_range( 0., 5. ) = 1.0;

void fragment()
{	
	// create mask, length( uv ) is for circle shape
	// change the uv scale to make it different
	float a = c_v - min(c_v, length( (UV - vec2(0.5, 1. - c_v)) * vec2( c_h, 1.0 )));
	
	COLOR = vec4( vec3(a), 1. );
}"

[sub_resource type="ShaderMaterial" id=14]
shader = SubResource( 13 )
shader_param/c_v = 0.25
shader_param/c_h = 1.0

[sub_resource type="Shader" id=15]
code = "shader_type canvas_item;

uniform float strength : hint_range( 1.0, 20.0 ) = 1.3;
uniform float speed : hint_range( 0.0, 20.0 ) = 0.;

uniform float contrast : hint_range( 0.0, 10.0 ) = 4.;
uniform float dnoise : hint_range( 0.0, 1.0 ) = 0.25;
uniform float whiteness : hint_range( 0.0, 20.0 ) = 10.;

uniform float power : hint_range(1., 20.) = 5.0;

uniform float height : hint_range( 0.0, 2.0 ) = 1.0;

uniform int crgb : hint_range(0,2) = 0;

uniform float c_v : hint_range( 0., 1. ) = 0.25;
uniform float c_h : hint_range( 0., 5. ) = 1.5;

// procedural noise from IQ
vec2 hash( vec2 p )
{
	p = vec2( dot(p,vec2(127.1,311.7)),
			 dot(p,vec2(269.5,183.3)) );
	return -1.0 + 2.0*fract(sin(p)*43758.5453123);
}

float noise( in vec2 p )
{
	const float K1 = 0.366025404; // (sqrt(3)-1)/2;
	const float K2 = 0.211324865; // (3-sqrt(3))/6;
	
	vec2 i = floor( p + (p.x+p.y)*K1 );
	
	vec2 a = p - i + (i.x+i.y)*K2;
	vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0);
	vec2 b = a - o + K2;
	vec2 c = a - 1.0 + 2.0*K2;
	
	vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );
	
	vec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));
	
	return dot( n, vec3(70.0) );
}

float fbm(vec2 uv)
{
	float f;
	mat2 m = mat2( vec2(1.6,  1.2), vec2(-1.2,  1.6) );
	f  = 0.5000*noise( uv ); uv = m*uv;
	f += 0.2500*noise( uv ); uv = m*uv;
	f += 0.1250*noise( uv ); uv = m*uv;
	f += 0.0625*noise( uv ); uv = m*uv;
	f = 0.5 + 0.5*f;
	return f;
}

int eq( int a, int b )
{
	return 1 - abs(sign(a - b));
}

void fragment()
{
	vec2 uv = UV - vec2( 0.5, 1. - c_v ); // uv.x [-0.5 ~ 0.5]
	float n = fbm(strength*UV + vec2(0,speed * TIME));
	
	// base color
	vec3 color = vec3(1.5*n, 1.5*n*n*n, n*n*n*n*n*n);
	
	// change bright and contrast 
	// float modifier = 1. - uv.y; // the lower, the darker
	// float modifier = pow(1. - uv.y, 0.4); // the more 'pow', the more darker range
	
	// float modifier = 1. - abs(uv.x); // closer to the center, the brighter
	// float modifier = pow(1. - abs(uv.x), 4.); // the more 'pow', the center is brigther
	
	// change color, color col is red, col.zyx is blue, .85*col.yxz is green
	color = color * vec3(float(eq( crgb, 0 ))) + color.zyx * vec3(float(eq( crgb, 1 ))) +  0.85 *  color.yxz * vec3(float(eq( crgb, 2 )));
	
	// change fire contrast, whiteness and dnoise
	color = color * vec3( whiteness * max(0., pow(n, contrast * max( 0., height - UV.y)) - dnoise));
	
	// create candle mask, length( uv ) is for circle shape
	float a = c_v - min(c_v, length( (UV - vec2(0.5, 1. - c_v)) * vec2( c_h, 1.0 )));
	
	// apply candle mask 
	color = color * a;
	
	COLOR = vec4( vec3(color), 1.);
}"

[sub_resource type="ShaderMaterial" id=16]
shader = SubResource( 15 )
shader_param/strength = 1.0
shader_param/speed = 0.0
shader_param/contrast = 4.0
shader_param/dnoise = 0.25
shader_param/whiteness = 10.0
shader_param/power = 5.0
shader_param/height = 0.922
shader_param/crgb = 0
shader_param/c_v = 0.5
shader_param/c_h = 0.0

[sub_resource type="Shader" id=17]
code = "shader_type canvas_item;

uniform float strength : hint_range( 1.0, 20.0 ) = 1.3;
uniform float speed : hint_range( 0.0, 20.0 ) = 0.;

uniform float contrast : hint_range( 0.0, 10.0 ) = 4.;
uniform float dnoise : hint_range( 0.0, 1.0 ) = 0.25;
uniform float whiteness : hint_range( 0.0, 20.0 ) = 10.;

uniform float power : hint_range(1., 20.) = 5.0;

uniform float height : hint_range( 0.0, 2.0 ) = 1.0;

uniform int crgb : hint_range(0,2) = 0;

uniform float c_v : hint_range( 0., 1. ) = 0.25;
uniform float c_h : hint_range( 0., 5. ) = 1.5;

// procedural noise from IQ
vec2 hash( vec2 p )
{
	p = vec2( dot(p,vec2(127.1,311.7)),
			 dot(p,vec2(269.5,183.3)) );
	return -1.0 + 2.0*fract(sin(p)*43758.5453123);
}

float noise( in vec2 p )
{
	const float K1 = 0.366025404; // (sqrt(3)-1)/2;
	const float K2 = 0.211324865; // (3-sqrt(3))/6;
	
	vec2 i = floor( p + (p.x+p.y)*K1 );
	
	vec2 a = p - i + (i.x+i.y)*K2;
	vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0);
	vec2 b = a - o + K2;
	vec2 c = a - 1.0 + 2.0*K2;
	
	vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );
	
	vec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));
	
	return dot( n, vec3(70.0) );
}

float fbm(vec2 uv)
{
	float f;
	mat2 m = mat2( vec2(1.6,  1.2), vec2(-1.2,  1.6) );
	f  = 0.5000*noise( uv ); uv = m*uv;
	f += 0.2500*noise( uv ); uv = m*uv;
	f += 0.1250*noise( uv ); uv = m*uv;
	f += 0.0625*noise( uv ); uv = m*uv;
	f = 0.5 + 0.5*f;
	return f;
}

int eq( int a, int b )
{
	return 1 - abs(sign(a - b));
}

void fragment()
{
	vec2 uv = UV - vec2( 0.5, 1. - c_v ); // uv.x [-0.5 ~ 0.5]
	float n = fbm(strength*UV + vec2(speed * TIME * 2.,speed * TIME));
	
	// base color
	vec3 color = vec3(1.5*n, 1.5*n*n*n, n*n*n*n*n*n);
	
	// change bright and contrast 
	// float modifier = 1. - uv.y; // the lower, the darker
	// float modifier = pow(1. - uv.y, 0.4); // the more 'pow', the more darker range
	
	// float modifier = 1. - abs(uv.x); // closer to the center, the brighter
	// float modifier = pow(1. - abs(uv.x), 4.); // the more 'pow', the center is brigther
	
	// change color, color col is red, col.zyx is blue, .85*col.yxz is green
	color = color * vec3(float(eq( crgb, 0 ))) + color.zyx * vec3(float(eq( crgb, 1 ))) +  0.85 *  color.yxz * vec3(float(eq( crgb, 2 )));
	
	// change fire contrast, whiteness and dnoise
	color = color * vec3( whiteness * max(0., pow(n, contrast * max( 0., height - UV.y)) - dnoise));
	
	// create candle mask, length( uv ) is for circle shape
	float a = c_v - min(c_v, length( (UV - vec2(0.5, 1. - c_v)) * vec2( c_h, 1.0 )));
	
	// apply candle mask 
	color = color * a;
	
	COLOR = vec4( vec3(color), 1.);
}"

[sub_resource type="ShaderMaterial" id=18]
shader = SubResource( 17 )
shader_param/strength = 7.82
shader_param/speed = 0.0
shader_param/contrast = 2.333
shader_param/dnoise = 0.054
shader_param/whiteness = 10.0
shader_param/power = 8.167
shader_param/height = 0.961
shader_param/crgb = 1
shader_param/c_v = 0.485
shader_param/c_h = 2.235

[node name="Node2D" type="Node2D"]
script = ExtResource( 1 )

[node name="ColorRect3" type="ColorRect" parent="."]
margin_right = 1024.0
margin_bottom = 600.0
rect_min_size = Vector2( 1024, 600 )
color = Color( 0, 0, 0, 1 )

[node name="ColorRect" type="ColorRect" parent="."]
material = SubResource( 2 )
rect_min_size = Vector2( 100, 300 )
color = Color( 0, 0, 0, 0 )

[node name="ColorRect2" type="ColorRect" parent="."]
material = SubResource( 4 )
margin_left = 100.0
margin_right = 200.0
margin_bottom = 300.0
rect_min_size = Vector2( 100, 300 )

[node name="ColorRect4" type="ColorRect" parent="."]
material = SubResource( 8 )
margin_left = 200.0
margin_right = 300.0
margin_bottom = 300.0
rect_min_size = Vector2( 100, 300 )

[node name="ColorRect5" type="ColorRect" parent="."]
material = SubResource( 10 )
margin_top = 300.0
margin_right = 100.0
margin_bottom = 600.0
rect_min_size = Vector2( 100, 300 )

[node name="ColorRect6" type="ColorRect" parent="."]
material = SubResource( 12 )
margin_left = 100.0
margin_top = 300.0
margin_right = 200.0
margin_bottom = 600.0
rect_min_size = Vector2( 100, 300 )

[node name="ColorRect7" type="ColorRect" parent="."]
material = SubResource( 14 )
margin_left = 200.0
margin_top = 300.0
margin_right = 300.0
margin_bottom = 600.0
rect_min_size = Vector2( 100, 300 )

[node name="ColorRect8" type="ColorRect" parent="."]
material = SubResource( 16 )
margin_left = 300.0
margin_top = 300.0
margin_right = 400.0
margin_bottom = 600.0
rect_min_size = Vector2( 100, 300 )

[node name="ColorRect9" type="ColorRect" parent="."]
material = SubResource( 18 )
margin_left = 400.0
margin_top = 300.0
margin_right = 500.0
margin_bottom = 600.0
rect_min_size = Vector2( 100, 300 )

[node name="Timer" type="Timer" parent="."]
one_shot = true

[node name="Timer2" type="Timer" parent="."]
autostart = true

[node name="Tween" type="Tween" parent="."]

[connection signal="timeout" from="Timer" to="." method="_on_Timer_timeout"]
[connection signal="timeout" from="Timer2" to="." method="_on_Timer2_timeout"]
